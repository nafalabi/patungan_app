package pages

import (
	"fmt"
	"patungan_app_echo/internal/models"
	"patungan_app_echo/web/templates/layouts"
	"patungan_app_echo/web/templates/shared"
)

// PlanFormProps contains props for the plan form page
type PlanFormProps struct {
	Title              string
	ActiveNav          string
	Breadcrumbs        []shared.Breadcrumb
	UserEmail          string
	UserUID            string
	IsEdit             bool
	Plan               models.Plan
	FormattedStartDate string
	AllUsers           []models.User // Available users to select
	// key: UserID, value: Portion (default 1)
	ParticipantPortions map[uint]int
}

// PlanForm renders the plan create/edit form
templ PlanForm(props PlanFormProps) {
	@layouts.Base(layouts.BaseProps{
		Title:       props.Title,
		ActiveNav:   props.ActiveNav,
		Breadcrumbs: props.Breadcrumbs,
		UserEmail:   props.UserEmail,
		UserUID:     props.UserUID,
	}) {
		<div class="max-w-[600px] mx-auto p-8 bg-bg-card rounded-2xl border border-border">
			<h1 class="text-2xl font-bold mb-6">
				if props.IsEdit {
					Edit Plan
				} else {
					Create New Plan
				}
			</h1>
			<form method="POST" action={ formAction(props.IsEdit, props.Plan.ID) }>
				<div class="mb-5">
					<label class="block mb-2 text-text-secondary">Plan Name</label>
					<input
						type="text"
						name="name"
						class="w-full p-2.5 rounded-lg border border-border bg-input-bg text-text-primary text-base focus:outline-none focus:border-primary"
						value={ props.Plan.Name }
						required
					/>
				</div>
				<div class="mb-5">
					<label class="block mb-2 text-text-secondary">Total Price (IDR)</label>
					<input
						type="number"
						name="total_price"
						class="w-full p-2.5 rounded-lg border border-border bg-input-bg text-text-primary text-base focus:outline-none focus:border-primary"
						value={ fmt.Sprintf("%.0f", props.Plan.TotalPrice) }
						required
					/>
				</div>
				<!-- Payment Type & Recurring Options (Alpine.js) -->
				<div
					class="mb-5"
					x-data={ fmt.Sprintf("recurringForm('%s', '%s')", props.Plan.PaymentType, derefString(props.Plan.RecurringInterval)) }
				>
					<div class="mb-5">
						<label class="block mb-2 text-text-secondary">Payment Type</label>
						<div class="flex items-center gap-4">
							<label class="flex items-center gap-2 cursor-pointer">
								<input
									type="radio"
									name="payment_type"
									value="onetime"
									x-model="paymentType"
									@change="updateRRule"
									class="text-primary focus:ring-primary"
								/>
								<span class="text-text-primary">One-time</span>
							</label>
							<label class="flex items-center gap-2 cursor-pointer">
								<input
									type="radio"
									name="payment_type"
									value="recurring"
									x-model="paymentType"
									@change="updateRRule"
									class="text-primary focus:ring-primary"
								/>
								<span class="text-text-primary">Recurring</span>
							</label>
						</div>
					</div>
					<!-- Recurring Options -->
					<div x-show="paymentType === 'recurring'" class="mb-5 p-4 border border-border rounded-lg bg-bg-body space-y-4">
						<div>
							<label class="block mb-2 text-text-secondary">Frequency</label>
							<select
								x-model="frequency"
								@change="updateRRule"
								class="w-full p-2.5 rounded-lg border border-border bg-input-bg text-text-primary text-base focus:outline-none focus:border-primary"
							>
								<option value="DAILY">Daily</option>
								<option value="WEEKLY">Weekly</option>
								<option value="MONTHLY">Monthly</option>
								<option value="YEARLY">Yearly</option>
							</select>
						</div>
						<div>
							<label class="block mb-2 text-text-secondary">Interval</label>
							<div class="flex items-center gap-2">
								<span class="text-text-primary">Every</span>
								<input
									type="number"
									min="1"
									x-model="interval"
									@input="updateRRule"
									class="w-20 p-2.5 rounded-lg border border-border bg-input-bg text-text-primary text-base focus:outline-none focus:border-primary"
								/>
								<span class="text-text-primary" x-text="frequency.toLowerCase().replace('ly', '(s)')"></span>
							</div>
						</div>
						<!-- Hidden Input for RRULE -->
						<input type="hidden" name="recurring_interval" x-model="rruleString"/>
					</div>
					<div class="mb-5">
						<label class="block mb-2 text-text-secondary">Start Date</label>
						<input
							type="date"
							name="plan_start_date"
							class="w-full p-2.5 rounded-lg border border-border bg-input-bg text-text-primary text-base focus:outline-none focus:border-primary"
							value={ props.FormattedStartDate }
							required
						/>
					</div>
				</div>
				<!-- Participants & Portions -->
				<div class="mb-5">
					<label class="block mb-2 text-text-secondary">Participants</label>
					<div class="space-y-2 border border-border rounded-lg p-4 max-h-60 overflow-y-auto bg-input-bg">
						if len(props.AllUsers) == 0 {
							<p class="text-text-secondary text-sm">No users available. Add users first.</p>
						} else {
							for _, user := range props.AllUsers {
								<div
									class="flex flex-col p-2 hover:bg-bg-hover rounded border border-transparent hover:border-border transition-all"
									x-data={ fmt.Sprintf("{ selected: %v, portion: %d }", props.ParticipantPortions[user.ID] > 0, max(1, props.ParticipantPortions[user.ID])) }
								>
									<label class="flex items-center cursor-pointer">
										<input
											type="checkbox"
											name="participants"
											value={ fmt.Sprintf("%d", user.ID) }
											id={ fmt.Sprintf("user-%d", user.ID) }
											class="mr-3 h-4 w-4 rounded border-border bg-bg-card text-primary focus:ring-primary"
											x-model="selected"
										/>
										<div class="flex flex-col select-none">
											<span class="text-text-primary font-medium">{ user.Name }</span>
											<span class="text-text-secondary text-xs">{ user.Email }</span>
										</div>
									</label>
									<div class="mt-2 ml-7 flex items-center gap-2" x-show="selected" x-transition>
										<label for={ fmt.Sprintf("portion-%d", user.ID) } class="text-xs text-text-secondary font-medium uppercase tracking-wide">Portion:</label>
										<input
											type="number"
											name={ fmt.Sprintf("portion_%d", user.ID) }
											id={ fmt.Sprintf("portion-%d", user.ID) }
											x-model="portion"
											min="1"
											class="w-20 px-2 py-1 bg-bg-body border border-border rounded text-text-primary text-sm focus:outline-none focus:border-primary"
											:disabled="!selected"
										/>
									</div>
								</div>
							}
						}
					</div>
					<p class="mt-2 text-xs text-text-secondary">Select users who will share this plan. Default portion is 1. Increase it if a user pays for multiple people.</p>
				</div>
				<div class="flex items-center gap-3 mb-6">
					<input
						type="checkbox"
						name="allow_invitation"
						id="allow_invitation"
						class="w-4 h-4 rounded border-border text-primary focus:ring-primary"
						checked?={ props.Plan.AllowInvitationAfterPay }
					/>
					<label for="allow_invitation" class="text-text-primary">Allow Invitation After Pay?</label>
				</div>
				<button type="submit" class="w-full inline-flex justify-center items-center gap-2 px-5 py-2.5 rounded-lg border-none cursor-pointer font-medium no-underline transition-all duration-200 bg-primary text-white hover:bg-primary-hover hover:-translate-y-px text-base">
					Save Plan
				</button>
				<a href="/plans" class="w-full inline-flex justify-center items-center gap-2 px-5 py-2.5 rounded-lg border border-border cursor-pointer font-medium no-underline transition-all duration-200 bg-transparent text-text-primary hover:bg-bg-hover mt-3 text-base">
					Cancel
				</a>
			</form>
		</div>
		<script>
			document.addEventListener('alpine:init', () => {
				Alpine.data('recurringForm', (initialType, initialRRule) => ({
					paymentType: initialType || 'onetime',
					frequency: 'WEEKLY',
					interval: 1,
					rruleString: initialRRule || '',
					init() {
						// Use a timeout to ensure rrule is loaded if deferred
						setTimeout(() => {
							if (this.paymentType === 'recurring' && this.rruleString && typeof rrule !== 'undefined') {
								try {
									const rule = rrule.rrulestr(this.rruleString);
									const options = rule.options;
									const freqMap = {};
									freqMap[rrule.RRule.DAILY] = 'DAILY';
									freqMap[rrule.RRule.WEEKLY] = 'WEEKLY';
									freqMap[rrule.RRule.MONTHLY] = 'MONTHLY';
									freqMap[rrule.RRule.YEARLY] = 'YEARLY';
									
									if (freqMap[options.freq]) {
										this.frequency = freqMap[options.freq];
									}
									if (options.interval) {
										this.interval = options.interval;
									}
								} catch (e) {
									console.error("Failed to parse RRULE:", e);
									this.updateRRule();
								}
							} else {
								this.updateRRule();
							}
						}, 100);
					},
					updateRRule() {
						if (this.paymentType !== 'recurring' || typeof rrule === 'undefined') {
							this.rruleString = '';
							return;
						}
						const freqMap = {
							'DAILY': rrule.RRule.DAILY,
							'WEEKLY': rrule.RRule.WEEKLY,
							'MONTHLY': rrule.RRule.MONTHLY,
							'YEARLY': rrule.RRule.YEARLY
						};
						const rule = new rrule.RRule({
							freq: freqMap[this.frequency],
							interval: parseInt(this.interval)
						});
						this.rruleString = rule.toString();
					}
				}))
			})
		</script>
	}
}

// Helper function to generate form action URL
func formAction(isEdit bool, planID uint) templ.SafeURL {
	if isEdit {
		return templ.SafeURL(fmt.Sprintf("/plans/%d/update", planID))
	}
	return templ.SafeURL("/plans")
}

func derefString(s *string) string {
	if s == nil {
		return ""
	}
	return *s
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
